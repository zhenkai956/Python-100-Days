# 06的笔记

## 同名函数的定义

后一个函数定义会复写前一个定义，因此可以用模块module（也就是文件.py的导入来区分），
下面是两种导入方式：

### 方式一：即饮即用

`test.py`

```Python
from module1 import foo

# 输出hello, world!
foo()

from module2 import foo

# 输出goodbye, world!
foo()
```

### 方式二：昵称备用

`test.py`

```Python
import module1 as m1
import module2 as m2
# 【注意】给起昵称的 是模组 而不是函数
m1.foo()
m2.foo()
```

## 模组中函数以外代码的屏蔽

增加条件，只有模组是主函数才执行其中的代码：

`module3.py`

```Python
def foo():
    pass


def bar():
    pass


# __name__是Python中一个隐含的变量它代表了模块的名字
# 只有被Python解释器直接执行的模块的名字才是__main__
if __name__ == '__main__':
    print('call foo()')
    foo()
    print('call bar()')
    bar()
```

`test.py`

```Python
import module3

# 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__
```

## 函数变量的作用域

### 作用域默认的搜索级别

每次提到某个变量名，编译器会在下面四个区域级别按次序搜索，一旦搜索到，就不再进入下一级别（更高更广的区域）进行搜索，

> Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些标识符，我们之前用过的`input`、`print`、`int`等都属于内置作用域。

例如，下面这段程序中，函数中的局部a在调用执行函数内代码时使用，任意修改不会影响外面的全局a。

```Python
def foo():
    a = 200
    print(a)  # 200


if __name__ == '__main__':
    a = 100
    foo()
    print(a)  # 100
```

### 手动指定作用域

此外可以通过`gloabal`和`nonlocal`等关键字符，来指定变量级别：
1.默认是局部，
2.然后是`nonlocal`的嵌套作用域，
3.然后是`gloabal`的全局作用域
4.内置的作者没讲……

```Python
def foo():
    global a
    a = 200
    print(a)  # 200


if __name__ == '__main__':
    a = 100
    foo()
    print(a)  # 200
```

### 利用作用域提高代码水平

更多地使用局部作用域，有助于：

- 不干扰全局变量的稳定性
- 程序的垃圾回收，有助于内存释放
- 程序各模块之间的独立性——迪米特法则

### 延长局部作用域变量的使用

> 如果我们希望将一个局部变量的生命周期延长，使其在定义它的函数调用结束后依然可以使用它的值，这时候就需要使用闭包，这个我们在后续的内容中进行讲解。
> 
> 很多人经常会将“闭包”和“匿名函数”混为一谈，但实际上它们并不是一回事

### 作者【总结建议】

作者建议将Python代码按照下面的格式进行书写：

```Python
def main():
    # Todo: Add your code here
    pass # 占空符，什么也不做，有些人用print()来替代


if __name__ == '__main__':
    main()
```

这里的含义是，把`.py`文件的主程序包装成一个main()函数，如果不作为主程序，而是作为模块被调用，那这部分内容就不会被执行，这个`.py`文件就仅仅是一个包含其他丰富函数的函数库而已。

这里还有个细节，函数定义在最前面，这样解析到后面才不会报错，且其它`.py`文件调用这个模块时能更快。

【完】
